// variable hoisting
console.log(number); // undefined

var number;
number = 30;

console.log(number); // 30

// 데이터 타입
// -> number, string, boolean, undifined, null, symbol / object

// 데이터 타입을 구분함으로써 
// 1) 값을 저장할 때 확보해야 할 메모리 공간의 크기를 결정
// 2) 값을 참조할 때 읽어들일 범위를 결정 ex) 숫자는 8바이트므로 8바이트 만큼 읽기
// 3) 메모리의 2진수를 어떻게 읽을지 결정 

// C, 자바와 같이 정적 선언이 아닌 동적으로 선언
// -> 유연하지만 신뢰성은 낮으므로 변수 남발은 지양하고 스코프를 좁게 사용하자 또는 상수를 사용

// 자바스크립트 엔진에서는 암묵적인 타입 변환이 일어난다. 
// 숫자를 기대하는 곳에서는 숫자로, boolean을 기대하는 곳에서는 boolean 으로 변환시킨다.

// 명시적 타입 변환은 String(), Number(), Boolean() 등이 있다.

// 단축 평가 : 논리 연산자 중 논리곱, 논리합은 boolean 이 아닌 데이터 타입을 반환한다.
// 1 && 2; -> 2 / 'hello' || 'world' -> hello'
// 단축 평가는 if else 문이나 여러가지 패턴에 사용 가능하다...

// 옵셔널 체이닝 연산자

// null 병합 연산자

// 객체는 뮤터블, 변경 가능한 값으로 프로퍼티로 구성
// 프로퍼티는 키와 값으로, 키는 문자열 또는 심벌 값, 값은 모든 값이 올 수 있다.

// 프로퍼티 접근에는 접근 연산자 . 또는 [] 을 사용할 수 있다.
// 대괄호 접근 연산자인 [] 에서 '' 로 감싸지 않으면 식별자로 인식한다.
// 존재하지 않는 프로퍼티 키에 접근할 경우 undefined 를 반환한다.
// 접근 연산자와 키로 동적 할당이 가능하며 delete 연산자로 프로퍼티를 삭제할 수 있다.

// 원시 타입 -> 값 전달 / 객체 타입 -> 참조값 전달

// 함수 정의
// 함수 선언문, 함수 표현식

// 기명 함수 리터럴 단독 사용 시 함수 선언문으로 해석
// () 과 같은 그룹 연산자 내 사용 -> 평가 가능한 리터럴을 기대 -> 함수 표현식으로 해석

function foo() {
  console.log('this is foo');
}
// 위와 같은 함수 선언문은 식별자가 없으므로 접근 불가능. 따라서 암묵적으로 식별자 생성.
// -> var foo = function foo() { ... }; 
// 함수 표현식으로 변환해 함수 객체를 생성하지만, 정확히 동일하게 동작하는 것은 아님.

// 함수의 호이스팅
console.log(add(1, 2));
console.log(sub(2, 1));

function add(argX, argY) {
  return argX + argY;
}

var sub = function (argX, argY) {
  return argX - argY;
}

// -> 함수 선언문의 경우 런타임 전 객체 생성



